#
# Copyright (C) SUSE LINUX GmbH 2016-2017, all rights reserved.
#
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation; either version 2.1 of the License, or
# (at your option) version 3.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.

function _fail() {
	echo "error: $*"
	exit 1
}

function _warn() {
	echo "warning: $*"
}

# process user defined configuration
. ${RAPIDO_DIR}/rapido.conf \
	|| _fail "rapido.conf missing - see rapido.conf.example"

function _rt_ceph_src_globals_set {
	[ -d "$CEPH_SRC" ] || _fail "$CEPH_SRC is not a directory"
	if [ -f "${CEPH_SRC}/build/CMakeCache.txt" ]; then
		# cmake build, compiled binaries and configs are in build subdir
		CEPH_MOUNT_BIN="${CEPH_SRC}/build/bin/mount.ceph"
		CEPH_FUSE_BIN="${CEPH_SRC}/build/bin/ceph-fuse"
		CEPH_RADOS_LIB="${CEPH_SRC}/build/lib/librados.so"
		CEPH_RBD_LIB="${CEPH_SRC}/build/lib/librbd.so"
		CEPH_COMMON_LIB="${CEPH_SRC}/build/lib/libceph-common.so.0"
		CEPHFS_LIB="${CEPH_SRC}/build/lib/libcephfs.so.2"
		CEPH_CONF="${CEPH_SRC}/build/ceph.conf"
		CEPH_KEYRING="${CEPH_SRC}/build/keyring"
	else
		# autotools build
		CEPH_MOUNT_BIN="${CEPH_SRC}/src/mount.ceph"
		CEPH_FUSE_BIN="${CEPH_SRC}/src/ceph-fuse"
		CEPH_RADOS_LIB="${CEPH_SRC}/src/.libs/librados.so"
		CEPH_RBD_LIB="${CEPH_SRC}/src/.libs/librbd.so"
		CEPH_COMMON_LIB="${CEPH_SRC}/src/.libs/libceph-common.so.0"
		CEPHFS_LIB="${CEPH_SRC}/src/.libs/libcephfs.so.2"
		CEPH_CONF="${CEPH_SRC}/src/ceph.conf"
		CEPH_KEYRING="${CEPH_SRC}/src/keyring"
	fi

	RBD_NAMER_BIN="${CEPH_SRC}/src/ceph-rbdnamer"
	RBD_UDEV_RULES="${CEPH_SRC}/udev/50-rbd.rules"
	CEPH_PTYPE_UDEV_RULES="${CEPH_SRC}/udev/60-ceph-by-parttypeuuid.rules"
}

function _rt_ceph_installed_globals_set {
	# use installed Ceph binaries and configs
	RBD_NAMER_BIN="/usr/bin/ceph-rbdnamer"
	RBD_UDEV_RULES="/usr/lib/udev/rules.d/50-rbd.rules"
	CEPH_PTYPE_UDEV_RULES="/usr/lib/udev/rules.d/60-ceph-by-parttypeuuid.rules"
	CEPH_MOUNT_BIN="/usr/sbin/mount.ceph"
	CEPH_FUSE_BIN="/usr/bin/ceph-fuse"
	CEPH_RADOS_LIB="/usr/lib64/librados.so"
	CEPH_RBD_LIB="/usr/lib64/librbd.so"
	CEPH_COMMON_LIB="/usr/lib64/libceph-common.so.0"
	CEPHFS_LIB="/usr/lib64/libcephfs.so.2"
	CEPH_CONF="/etc/ceph/ceph.conf"
	CEPH_KEYRING="/etc/ceph/ceph.client.${CEPH_USER}.keyring"
}

function _rt_require_ceph {
	if [ -n "$CEPH_SRC" ]; then
		_rt_ceph_src_globals_set
	else
		_rt_ceph_installed_globals_set
	fi

	[ -f "$RBD_NAMER_BIN" ] || _fail "missing $RBD_NAMER_BIN"
	[ -f "$RBD_UDEV_RULES" ] || _fail "missing $RBD_UDEV_RULES"
	[ -f "$CEPH_PTYPE_UDEV_RULES" ] || _fail "missing $CEPH_PTYPE_UDEV_RULES"
	[ -f "$CEPH_MOUNT_BIN" ] || _fail "missing $CEPH_MOUNT_BIN"
	[ -f "$CEPH_FUSE_BIN" ] || _fail "missing $CEPH_FUSE_BIN"
	[ -f "$CEPH_RADOS_LIB" ] || _fail "missing $CEPH_RADOS_LIB"
	[ -f "$CEPH_RBD_LIB" ] || _fail "missing $CEPH_RBD_LIB"
	[ -f "$CEPH_COMMON_LIB" ] || _fail "missing $CEPH_COMMON_LIB"
	[ -f "$CEPHFS_LIB" ] || _fail "missing $CEPHFS_LIB"
	[ -f "$CEPH_CONF" ] || _fail "missing $CEPH_CONF"
	[ -f "$CEPH_KEYRING" ] || _fail "missing $CEPH_KEYRING"
}

function _rt_require_fstests() {
	_rt_require_conf_dir FSTESTS_SRC
	[ -x "$FSTESTS_SRC/check" ] || _fail "missing $FSTESTS_SRC/check"
}

function _rt_require_blktests() {
	_rt_require_conf_dir BLKTESTS_SRC
	[ -x "$BLKTESTS_SRC/check" ] || _fail "missing $BLKTESTS_SRC/check"
}

function _rt_require_zram_params {
	# initramfs ramdisk details
	ZRAM_INITRD_SIZE="1G"
	ZRAM_INITRD_MNT="$RAPIDO_DIR/initrds"
}

function _rt_require_dracut_args() {
	[ -f "${KERNEL_SRC}/include/config/kernel.release" ] \
		|| _fail "kernel.release file missing $KERNEL_SRC"
	local kver="$(cat ${KERNEL_SRC}/include/config/kernel.release)"

	# --confdir sees Dracut use rapido specific configuration, instead of
	# processing /etc/dracut.conf.d/*.conf
	local dracut_args="--confdir ${RAPIDO_DIR}/dracut.conf.d \
			   --force --tmpdir ${RAPIDO_DIR}/initrds/ \
			   --kver $kver"

	if [ -n "$DRACUT_SRC" ]; then
		DRACUT="$DRACUT_SRC/dracut.sh"
		dracut_args=" --local $dracut_args"
	else
		DRACUT="dracut"
	fi
	$DRACUT --list-modules &>/dev/null \
		|| _fail "cannot run $DRACUT"

	# The optional KERNEL_INSTALL_MOD_PATH rapido.conf parameter can be used
	# to specify where Dracut should try to pull built kernel modules from.
	if [ -n "$KERNEL_INSTALL_MOD_PATH" ]; then
		local kmoddir="$KERNEL_INSTALL_MOD_PATH/lib/modules/$kver"
		[ -d "$kmoddir" ] \
				|| _fail "missing $kmoddir"
		dracut_args="$dracut_args --kmoddir $kmoddir"
	fi

	DRACUT_EXTRA_ARGS="$DRACUT_EXTRA_ARGS $dracut_args"
}

function _rt_require_qemu_kvm_bin {
	QEMU_KVM_BIN="$(which qemu-kvm 2>/dev/null)"

	if [ -z "$QEMU_KVM_BIN" ]; then
		# Debian uses kvm instead of qemu-kvm
		QEMU_KVM_BIN="$(which kvm 2>/dev/null)"
	fi

	[ -z "$QEMU_KVM_BIN" ] && _fail "missing qemu-kvm"
}

function _rt_require_lib()
{
	local libname=""
	for libname in $1; do
		local library=`/sbin/ldconfig -p \
			| awk 'index($1, "'${libname}'") == 1 {print $NF}'`
		[ -n "$library" ] || _fail "can't find library '$libname'"
		LIBS_INSTALL_LIST="$LIBS_INSTALL_LIST $library"
	done
}

# check that each parameter is set in rapido.conf, and corresponds to a local
# directory.
function _rt_require_conf_dir {
	local parms=("$@")
	local conf
	local dir
	for conf in "${parms[@]}"; do
		eval "dir=\${$conf}"
		[ -n "$dir" ] || _fail "$conf is not set"
		[ -d "$dir" ] || _fail "$conf (${dir}) is not a directory"
	done
}

function _rt_require_samba_ctdb {
	_rt_require_conf_dir SAMBA_SRC
	[ -x "${SAMBA_SRC}/bin/default/ctdb/ctdb" ] || _fail "ctdb not found"
	[ -x "${SAMBA_SRC}/bin/default/ctdb/ctdbd" ] || _fail "ctdbd not found"
	# renamed with 4.9 events.d -> event
	CTDB_EVENTS_DIR="$(ls -d ${SAMBA_SRC}/ctdb/config/events*)"
	[ -d "$CTDB_EVENTS_DIR" ] || _fail "$CTDB_EVENTS_DIR missing"
}

# initramfs output path
DRACUT_OUT="${RAPIDO_DIR}/initrds/myinitrd"

function _rt_xattr_qemu_args_set
{
	local img="$1"
	local qemu_args="$2"
	local xattr_key="user.rapido.qemu_args"

	[ -n "$img" ] || _fail "img parameter is manditory"
	[ -f "$img" ] || _fail "no image at $img"
	[ -n "$qemu_args" ] || _fail "qemu_args parameter is manditory"

	setfattr -n "$xattr_key" -v "$qemu_args" $img \
		|| _fail "failed to set xattr on $img"
}

function _rt_xattr_qemu_args_get
{
	local img="$1"
	local xattr_key="user.rapido.qemu_args"

	[ -n "$img" ] || _fail "img parameter is manditory"
	[ -f "$img" ] || _fail "no image at $img"

	getfattr --only-values -n $xattr_key $img 2> /dev/null
}

function _rt_xattr_vm_networkless_set
{
	local img="$1"
	local xattr_key="user.rapido.vm_networkless"

	[ -n "$img" ] || _fail "img parameter is manditory"
	[ -f "$img" ] || _fail "no image at $img"

	setfattr -n "$xattr_key" -v "1" $img \
		|| _fail "failed to set xattr on $img"
}

function _rt_xattr_vm_networkless_get
{
	local img="$1"
	local xattr_key="user.rapido.vm_networkless"

	[ -n "$img" ] || _fail "img parameter is manditory"
	[ -f "$img" ] || _fail "no image at $img"

	getfattr --only-values -n $xattr_key $img 2> /dev/null
}

function _rt_xattr_vm_resources_set
{
	local img="$1"
	local cpus="$2"
	local mem="$3"
	local xattr_key="user.rapido.vm_resources"
	local re='^[0-9]+$'

	[ -n "$img" ] || _fail "img parameter is manditory"
	[ -f "$img" ] || _fail "no image at $img"
	[[ $cpus =~ $re ]] || _fail "num CPUs must be numeric"
	re='^[0-9]+[MGmg]?$'
	[[ $mem =~ $re ]] || _fail "invalid memory string: $mem"

	setfattr -n "$xattr_key" -v "-smp cpus=${cpus} -m $mem" $img \
		|| _fail "failed to set xattr on $img"
}

function _rt_xattr_vm_resources_get
{
	local img="$1"
	local xattr_key="user.rapido.vm_resources"

	[ -n "$img" ] || _fail "img parameter is manditory"
	[ -f "$img" ] || _fail "no image at $img"

	getfattr --only-values -n $xattr_key $img 2> /dev/null
}
